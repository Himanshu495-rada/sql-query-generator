import api from "../utils/api";

// Types for playground operations
export interface Playground {
  id: string;
  name: string;
  databaseId: string | null;
  currentSql: string;
  currentPrompt: string;
  currentExplanation: string;
  history: QueryHistoryItem[];
  lastUpdated: Date;
}

export interface QueryHistoryItem {
  id: string;
  prompt: string;
  sql: string;
  timestamp: Date;
  hasError: boolean;
  error?: string;
  rowCount?: number;
  executionTime?: number;
  explanation?: string;
}

/**
 * Service for managing SQL playgrounds
 */
class PlaygroundService {
  /**
   * Get all playgrounds for the current user
   */
  async getPlaygrounds(): Promise<Playground[]> {
    try {
      console.log('Fetching playgrounds from API...');
      const response = await api.get('playgrounds');
      
      console.log('API Response:', response);
      
      // Handle successful API response
      if (response?.data?.success === true && response?.data?.data?.playgrounds) {
        const playgroundsData = response.data.data.playgrounds;
        
        // Ensure we have an array of playgrounds
        if (Array.isArray(playgroundsData) && playgroundsData.length > 0) {
          console.log(`Successfully loaded ${playgroundsData.length} playgrounds from API`);
          
          // Convert API data to our Playground interface
          return playgroundsData.map((pg: any) => ({
            id: pg.id,
            name: pg.name,
            databaseId: pg.connections && pg.connections.length > 0 ? 
              pg.connections[0]?.connectionId : null,
            currentSql: pg.currentSql || '',
            currentPrompt: pg.currentPrompt || '',
            currentExplanation: pg.currentExplanation || '',
            history: Array.isArray(pg.history) ? pg.history.map((item: any) => ({
              ...item,
              timestamp: new Date(item.timestamp || Date.now()),
            })) : [],
            lastUpdated: new Date(pg.updatedAt || pg.createdAt || Date.now())
          }));
        }
      }
      
      console.warn('API did not return valid playground data, returning empty array');
      return [];
    } catch (error) {
      console.error('Error fetching playgrounds:', error);
      return []; // Return empty array on error to prevent UI breakage
    }
  }

  /**
   * Get a playground by ID
   */
  async getPlayground(id: string): Promise<Playground | null> {
    try {
      console.log(`Fetching playground with ID ${id}`);
      const response = await api.get(`playgrounds/${id}`);
      
      // Check if API returned valid data
      if (response?.data?.success === true && response?.data?.data?.playground) {
        const playgroundData = response.data.data.playground;
        
        // Format the playground data to match the Playground interface
        return {
          id: playgroundData.id,
          name: playgroundData.name,
          databaseId: playgroundData.connections && playgroundData.connections.length > 0 ? 
            playgroundData.connections[0]?.connectionId : null,
          currentSql: playgroundData.currentSql || '',
          currentPrompt: playgroundData.currentPrompt || '',
          currentExplanation: playgroundData.currentExplanation || '',
          history: Array.isArray(playgroundData.history) ? playgroundData.history.map((item: any) => ({
            ...item,
            timestamp: new Date(item.timestamp || Date.now()),
          })) : [],
          lastUpdated: new Date(playgroundData.updatedAt || playgroundData.createdAt || Date.now()),
        };
      }
      
      console.warn(`No playground found with ID ${id}`);
      return null;
    } catch (error) {
      console.error(`Error fetching playground with ID ${id}:`, error);
      return null; // Return null on error
    }
  }

  /**
   * Create a new playground
   */
  async createPlayground(name: string, databaseId: string | null = null): Promise<Playground | null> {
    try {
      console.log(`Creating playground: ${name}`);
      const response = await api.post('playgrounds', { name, databaseId });
      
      // Check if API returned valid data
      if (response?.data?.success === true && response?.data?.data?.playground) {
        const playgroundData = response.data.data.playground;
        
        // Format the playground data to match the Playground interface
        return {
          id: playgroundData.id,
          name: playgroundData.name,
          databaseId: playgroundData.connections && playgroundData.connections.length > 0 ? 
            playgroundData.connections[0]?.connectionId : null,
          currentSql: '',
          currentPrompt: '',
          currentExplanation: '',
          history: [],
          lastUpdated: new Date(playgroundData.updatedAt || playgroundData.createdAt || Date.now()),
        };
      }
      
      console.warn('Failed to create playground');
      return null;
    } catch (error) {
      console.error('Error creating playground:', error);
      return null; // Return null on error
    }
  }

  /**
   * Update a playground
   */
  async updatePlayground(id: string, updates: Partial<Playground>): Promise<Playground | null> {
    try {
      console.log(`Updating playground with ID ${id}`);
      const response = await api.put(`playgrounds/${id}`, updates);
      
      // Check if API returned valid data
      if (response?.data?.success === true && response?.data?.data?.playground) {
        const playgroundData = response.data.data.playground;
        
        // Format the playground data to match the Playground interface
        return {
          id: playgroundData.id,
          name: playgroundData.name,
          databaseId: playgroundData.connections && playgroundData.connections.length > 0 ? 
            playgroundData.connections[0]?.connectionId : null,
          currentSql: playgroundData.currentSql || '',
          currentPrompt: playgroundData.currentPrompt || '',
          currentExplanation: playgroundData.currentExplanation || '',
          history: Array.isArray(playgroundData.history) ? playgroundData.history.map((item: any) => ({
            ...item,
            timestamp: new Date(item.timestamp || Date.now()),
          })) : [],
          lastUpdated: new Date(playgroundData.updatedAt || playgroundData.createdAt || Date.now()),
        };
      }
      
      console.warn(`Failed to update playground with ID ${id}`);
      return null;
    } catch (error) {
      console.error(`Error updating playground with ID ${id}:`, error);
      return null; // Return null on error
    }
  }

  /**
   * Delete a playground
   */
  async deletePlayground(id: string): Promise<boolean> {
    try {
      console.log(`Deleting playground with ID ${id}`);
      const response = await api.delete(`playgrounds/${id}`);
      
      return response?.data?.success === true;
    } catch (error) {
      console.error(`Error deleting playground with ID ${id}:`, error);
      return false; // Return false on error
    }
  }
}

export default new PlaygroundService();
